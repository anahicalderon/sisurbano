# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Sisurbano
                                 A QGIS plugin
 Cáculo de indicadores urbanos
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-09-16
        copyright            : (C) 2019 by LlactaLAB
        email                : johnatan.astudillo@ucuenca.edu.ec
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Johnatan Astudillo'
__date__ = '2019-09-16'
__copyright__ = '(C) 2019 by LlactaLAB'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import os

from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.core import (QgsProcessing,
                       QgsProcessingMultiStepFeedback,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterField,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFeatureSink)
from .ZProcesses import *
from .Zettings import *
from .ZHelpers import *
import numpy as np
import pandas as pd
import tempfile
import subprocess

pluginPath = os.path.split(os.path.split(os.path.dirname(__file__))[0])[0]

class ID07QualityLifeIndex(QgsProcessingAlgorithm):
    """
    Mide el nivel de carencia o bienestar de quienes habitan una
    vivienda en base a las siguientes variables: a) Características
    físicas de la vivienda, que integra tanto la calidad de la vivienda
    en pisos, paredes exteriores y techo, como la “cantidad de la vivienda”
    medida en hacinamiento de sus habitantes; b) Servicios básicos de
    la vivienda, que integra la información relacionada a servicios de
    agua y saneamiento, energía y comunicaciones; c) Educación, que
    caracteriza del nivel educativo de la población mayor a seis años; y
    d) Acceso a servicios de salud, que analiza el acceso de
    la población a un seguro de salud público o privado.  
    Formula: (Porcentaje de la población del Cuartil uno en el Secto i / Porcentaje de la población del Cuartil en toda la ciudad)*100
    """

    BLOCKS = 'BLOCKS'
    DPA_MAN = 'DPA_MAN'
    CENSO_VIVIENDA = 'CENSO_VIVIENDA'
    CENSO_POBLACION = 'CENSO_POBLACION'
    CENSO_HOGAR = 'CENSO_HOGAR'
    CELL_SIZE = 'CELL_SIZE'
    OUTPUT = 'OUTPUT'
    STUDY_AREA_GRID = 'STUDY_AREA_GRID'
    CURRENT_PATH = 'CURRENT_PATH'    

    def initAlgorithm(self, config):
        currentPath = getCurrentPath(self)
        self.CURRENT_PATH = currentPath        
        FULL_PATH = buildFullPathName(currentPath, nameWithOuputExtension(NAMES_INDEX['ID07'][1]))

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.BLOCKS,
                self.tr('Manzanas'),
                [QgsProcessing.TypeVectorPolygon]
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                self.DPA_MAN,
                self.tr('DPA Manzanas'),
                'dpa_manzan', 'BLOCKS'
            )
        )           

        # self.addParameter(
        #     QgsProcessingParameterFile(
        #         self.CENSO_POBLACION,
        #         self.tr('Censo población'),
        #         extension='csv',
        #         defaultValue=""
        #     )
        # ) 

        # self.addParameter(
        #     QgsProcessingParameterFile(
        #         self.CENSO_HOGAR,
        #         self.tr('Censo hogar'),
        #         extension='csv',
        #         defaultValue=""
        #     )
        # )           

        # self.addParameter(
        #     QgsProcessingParameterFile(
        #         self.CENSO_VIVIENDA,
        #         self.tr('Censo vivienda'),
        #         extension='csv',
        #         defaultValue=''
        #     )
        # )           



        self.addParameter(
            QgsProcessingParameterFile(
                self.CENSO_POBLACION,
                self.tr('Censo población'),
                extension='csv',
                defaultValue="/Users/terra/llactalab/data/mali/Cotopaxi_CSV_Poblac.csv"
                # defaultValue=""
            )
        ) 

        self.addParameter(
            QgsProcessingParameterFile(
                self.CENSO_HOGAR,
                self.tr('Censo hogar'),
                extension='csv',
                defaultValue="/Users/terra/llactalab/data/mali/Cotopaxi_CSV_Hogar.csv"
                # defaultValue=""
            )
        )           

        self.addParameter(
            QgsProcessingParameterFile(
                self.CENSO_VIVIENDA,
                self.tr('Censo vivienda'),
                extension='csv',
                defaultValue='/Users/terra/llactalab/data/mali/Cotopaxi_CSV_Vivienda.csv'
                # defaultValue=''
            )
        )    

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.STUDY_AREA_GRID,
                self.tr(TEXT_GRID_INPUT),
                [QgsProcessing.TypeVectorPolygon],
                '', OPTIONAL_GRID_INPUT
            )
        )


        if OPTIONAL_GRID_INPUT:
            self.addParameter(
                QgsProcessingParameterNumber(
                    self.CELL_SIZE,
                    self.tr('Tamaño de la malla'),
                    QgsProcessingParameterNumber.Integer,
                    P_CELL_SIZE, False, 1, 99999999
                )
            )          


        # self.addParameter(
        #     QgsProcessingParameterNumber(
        #         self.NUMBER_HABITANTS,
        #         self.tr('Por cada número de habitantes'),
        #         QgsProcessingParameterNumber.Integer,
        #         100000, False, 1, 99999999
        #     )
        # )   

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Salida'),
                QgsProcessing.TypeVectorAnyGeometry,
                str(FULL_PATH)
            )
        )
        

    def processAlgorithm(self, params, context, feedback):
        steps = 0
        totalStpes = 26
        fieldDpaMan = params['DPA_MAN']
        # fieldHab = params['NUMBER_HABITANTS']

        feedback = QgsProcessingMultiStepFeedback(totalStpes, feedback)

        if not OPTIONAL_GRID_INPUT: params['CELL_SIZE'] = P_CELL_SIZE
        grid, isStudyArea = buildStudyArea(params['CELL_SIZE'], params['BLOCKS'],
                                         params['STUDY_AREA_GRID'],
                                         context, feedback)
        gridNeto = grid  


        steps = steps+1
        feedback.setCurrentStep(steps)


        pathCsvPoblacion = params['CENSO_POBLACION']
        pathCsvHogar = params['CENSO_HOGAR']
        pathCsvVivienda = params['CENSO_VIVIENDA']

        file = pathCsvPoblacion
        cols = ['I01', 'I02', 'I03', 'I04', 'I05', 'I06', 'I09', 'I10', 'P02', 'P03', 'P07', 'P35', 'GRAESC']
        df = pd.read_csv(file, usecols=cols)

        # fix codes 
        df['I01'] = df['I01'].astype(str)
        df['I02'] = df['I02'].astype(str)
        df['I03'] = df['I03'].astype(str)
        df['I04'] = df['I04'].astype(str)
        df['I05'] = df['I05'].astype(str)
        df['I06'] = df['I06'].astype(str)
        df['I09'] = df['I09'].astype(str)
        df['I10'] = df['I10'].astype(str)

        df.loc[df['I01'].str.len() < 2, 'I01'] = "0" + df['I01']
        df.loc[df['I02'].str.len() < 2, 'I02'] = "0" + df['I02']
        df.loc[df['I03'].str.len() < 2, 'I03'] = "0" + df['I03']
        df.loc[df['I04'].str.len() == 1, 'I04'] = "00" + df['I04']
        df.loc[df['I04'].str.len() == 2, 'I04'] = "0" + df['I04']
        df.loc[df['I05'].str.len() == 1, 'I05'] = "00" + df['I05']
        df.loc[df['I05'].str.len() == 2, 'I05'] = "0" + df['I05']
        df.loc[df['I06'].str.len() < 2, 'I06'] = "0" + df['I06']
        df.loc[df['I09'].str.len() == 1, 'I09'] = "00" + df['I09']
        df.loc[df['I09'].str.len() == 2, 'I09'] = "0" + df['I09']
        df.loc[df['I10'].str.len() < 2, 'I10'] = "0" + df['I10']

        #1. CALCULO DEL INDICADOR DE SEGURIDAD SOCIAL (SALUD).
        #1.1 Diferenciar quiénes están afiliados a cualquier seguro social (IESS, ISSFA, ISSPOL).
        df['seguridad_social'] = None
        df.loc[df['P35'] == '7', 'seguridad_social'] = 0
        df.loc[df['P35'] == '9', 'seguridad_social'] = 0
        df.loc[(df['P35'] >= '1') & (df['P35'] <= '6'), 'seguridad_social'] = 1

        
        #1.2 Utilizar una variable auxiliar para incorporar a los hijos que tendrán 
        #servicio de salud, primero ubicamos a los jefes de familia con seguro social.
        #agrupamos los codigos
        df['cod'] = df['I01'].astype(str) + df['I02'].astype(str) + df['I03'].astype(str) \
                  + df['I04'].astype(str) + df['I05'].astype(str) + df['I09'].astype(str) \
                  + df['I10'].astype(str)

        original =  pd.DataFrame(df)
        group = df.groupby(['cod']).first()
        group = group['seguridad_social']
        merge = pd.merge(original, group,  how='left', on='cod')

        #1.3 Calcular Seguridad social para todo el hogar. Incluye a conyugue e hijos de afiliado, ademas de seguro privado.
        df = merge
        df['salud'] = 0
        df.loc[df['seguridad_social_x'] == 1, 'salud'] = 1
        df.loc[df['P07'] == 1, 'salud'] = 1
        df.loc[(df['P03'] < 19) & (df['P02'] == 3 ) & (df['seguridad_social_y'] == 1), 'salud'] = 1
        df.loc[(df['P02'] == 2) & (df['seguridad_social_y'] == 1), 'salud'] = 1

        #1.4 Calcular una media de seguridad social por vivienda.
        df['codf'] = df['I01'].astype(str) + df['I02'].astype(str) + df['I03'].astype(str) \
                  + df['I04'].astype(str) + df['I05'].astype(str) + df['I09'].astype(str)
        group = df.groupby(['codf']).mean()
        group = group['salud']
        merge = pd.merge(df, group,  how='left', on='codf')        

        #2. CALCULO DEL INDICADOR DE EDUCACION. 
        #recordar aislar valor 99 (no contesta) en GRAESC 
        #2.1 Calcular los anos de educacion requeridos por edad. Anos que deben haber estudiado.
        df = merge
        df['anos_educ'] = None
        df.loc[df['P03'] == 8, 'anos_educ'] = 2
        df.loc[df['P03'] == 9, 'anos_educ'] = 3
        df.loc[df['P03'] == 10, 'anos_educ'] = 4
        df.loc[df['P03'] == 11, 'anos_educ'] = 5
        df.loc[df['P03'] == 12, 'anos_educ'] = 6
        df.loc[df['P03'] == 13, 'anos_educ'] = 7
        df.loc[df['P03'] == 14, 'anos_educ'] = 8
        df.loc[df['P03'] == 15, 'anos_educ'] = 9
        df.loc[df['P03'] == 16, 'anos_educ'] = 10
        df.loc[df['P03'] == 17, 'anos_educ'] = 11
        df.loc[df['P03'] == 18, 'anos_educ'] = 12
        df.loc[(df['P03'] >= 0) & (df['P03'] <= 7), 'anos_educ'] = 1
        df.loc[(df['P03'] >= 19), 'anos_educ'] = 13        

        #2.2 Calcular la adecuacion educativa de cada persona en el hogar.
        df.loc[df['P03'] <= 6, 'GRAESC'] = 0.0
        df['educacion'] = None
        df.loc[(df['P03'] > 6) & (df['GRAESC'].astype(float) != 99), 'educacion'] = df['GRAESC'].astype(float) / df['anos_educ'].astype(float)
        #2.3 Esta variable requiere de una recodificacion, puesto que hay casos en los 
        #que su nivel de educacion sobrepasa el maximo de 2.
        #2.3.1 Primero recalcular los datos mayores a 1.
        #Ojo, el numero 4 de la formula, puede variar dependiendo del maximo.
        maxEducation = df['educacion'].max()
        df['eduacion_recode'] = None
        df.loc[df['educacion'] > 1, 'eduacion_recode'] = 1 +  ((df['educacion'] - 1) / (maxEducation - 1))
        #2.3.2 Segundo generar una nueva variable donde copio los casos menores a 1 de la adecuacion educativa.
        #2.3.3 Tercero, copiar los valores mayores a 1 que estan recalculados.
        df.loc[df['educacion'] <= 1, 'eduacion_recode'] = df['educacion']
        #2.4 Calcular la media de educacion por vivienda.
        df['codv'] = df['I01'].astype(str) + df['I02'].astype(str) + df['I03'].astype(str) \
                  + df['I04'].astype(str) + df['I05'].astype(str) +  df['I06'].astype(str) \
                  + df['I09'].astype(str)

        df['eduacion_recode'] = df['eduacion_recode'].astype(float)
        group = df.groupby('codv')['eduacion_recode'].mean()

        merge = pd.merge(df, group,  how='left', on='codv')
        df = merge
        dfP = df        

        #POR ULTIMO, ES NECESARIO PEGAR LAS MEDIAS EN LA BASE DE DATOS DE VIVIENDA.

        fileV = pathCsvVivienda
        colsV = ['I01', 'I02', 'I03', 'I04', 'I05', 'I06', 'I09', 
                 'I10', 'V01', 'V03', 'V05', 'V08', 'V09', 'V10', 
                 'V13', 'V14', 'TOTPER',
                ]
        dfV = pd.read_csv(fileV, usecols=colsV)

        # fix codes 
        dfV['I01'] = dfV['I01'].astype(str)
        dfV['I02'] = dfV['I02'].astype(str)
        dfV['I03'] = dfV['I03'].astype(str)
        dfV['I04'] = dfV['I04'].astype(str)
        dfV['I05'] = dfV['I05'].astype(str)
        dfV['I06'] = dfV['I06'].astype(str)
        dfV['I09'] = dfV['I09'].astype(str)
        dfV['I10'] = dfV['I10'].astype(str)

        dfV.loc[dfV['I01'].str.len() < 2, 'I01'] = "0" + dfV['I01']
        dfV.loc[dfV['I02'].str.len() < 2, 'I02'] = "0" + dfV['I02']
        dfV.loc[dfV['I03'].str.len() < 2, 'I03'] = "0" + dfV['I03']
        dfV.loc[dfV['I04'].str.len() == 1, 'I04'] = "00" + dfV['I04']
        dfV.loc[dfV['I04'].str.len() == 2, 'I04'] = "0" + dfV['I04']
        dfV.loc[dfV['I05'].str.len() == 1, 'I05'] = "00" + dfV['I05']
        dfV.loc[dfV['I05'].str.len() == 2, 'I05'] = "0" + dfV['I05']
        dfV.loc[dfV['I06'].str.len() < 2, 'I06'] = "0" + dfV['I06']
        dfV.loc[dfV['I09'].str.len() == 1, 'I09'] = "00" + dfV['I09']
        dfV.loc[dfV['I09'].str.len() == 2, 'I09'] = "0" + dfV['I09']
        dfV.loc[dfV['I10'].str.len() < 2, 'I10'] = "0" + dfV['I10']

        dfV['codv'] = dfV['I01'].astype(str) + dfV['I02'].astype(str) + dfV['I03'].astype(str) \
                  + dfV['I04'].astype(str) + dfV['I05'].astype(str) +  dfV['I06'].astype(str) \
                  + dfV['I09'].astype(str)

        #seguridad social agrupado por vivienda 
        seguridad = df.groupby('codv')['salud_y'].first()
        #educacion
        educacion = df.groupby('codv')['eduacion_recode_y'].first()

        merge = pd.merge(dfV, seguridad,  how='left', on='codv')
        merge = pd.merge(merge, educacion,  how='left', on='codv')
        merge.rename(columns={'salud_y':'MEDIA_SEG_SOCIAL'}, inplace=True) 
        merge.rename(columns={'eduacion_recode_y':'MEDIA_EDUCACION'}, inplace=True)
        dfV = merge        

        # TRABAJAR EN LA BASE DE DATOS DE HOGAR DEL CENSO 2010, ECUADOR.

        fileH = pathCsvHogar
        colsH = ['I01', 'I02', 'I03', 'I04', 'I05', 'I06', 'I09', 'H01', 'H02', 'H03', 'H05', 'H07','H08', 'H09', 'H11','TP1']
        df = pd.read_csv(fileH, usecols=colsH)

        # fix codes 
        df['I01'] = df['I01'].astype(str)
        df['I02'] = df['I02'].astype(str)
        df['I03'] = df['I03'].astype(str)
        df['I04'] = df['I04'].astype(str)
        df['I05'] = df['I05'].astype(str)
        df['I06'] = df['I06'].astype(str)
        df['I09'] = df['I09'].astype(str)

        df.loc[df['I01'].str.len() < 2, 'I01'] = "0" + df['I01']
        df.loc[df['I02'].str.len() < 2, 'I02'] = "0" + df['I02']
        df.loc[df['I03'].str.len() < 2, 'I03'] = "0" + df['I03']
        df.loc[df['I04'].str.len() == 1, 'I04'] = "00" + df['I04']
        df.loc[df['I04'].str.len() == 2, 'I04'] = "0" + df['I04']
        df.loc[df['I05'].str.len() == 1, 'I05'] = "00" + df['I05']
        df.loc[df['I05'].str.len() == 2, 'I05'] = "0" + df['I05']
        df.loc[df['I06'].str.len() < 2, 'I06'] = "0" + df['I06']
        df.loc[df['I09'].str.len() == 1, 'I09'] = "00" + df['I09']
        df.loc[df['I09'].str.len() == 2, 'I09'] = "0" + df['I09']

        # *1. CÁLCULO DEL INDICADOR INTEGRADO DE COMUNICACIÓN.
        # *1.1 Calcular la disponibilidad de telefonía fija en el hogar.
        df['telefono'] = None
        df.loc[df['H07'] == '1', 'telefono'] = 1
        df.loc[df['H07'] == '2', 'telefono'] = 0

        # *1.2 Calcular la disponibilidad de celular en el hogar.
        df['celular'] = None
        df.loc[df['H08'] == '1', 'celular'] = 1
        df.loc[df['H08'] == '2', 'celular'] = 0

        # *1.4 Calcular la disponibilidad de internet en el hogar.
        df['internet'] = None
        df.loc[df['H09'] == '1', 'internet'] = 1
        df.loc[df['H09'] == '2', 'internet'] = 0

        # *1.5 Calcular la disponibilidad de Tv Cable.
        df['tvcable'] = None
        df.loc[df['H11'] == '1', 'tvcable'] = 2
        df.loc[df['H11'] == '2', 'tvcable'] = 1

        # *1.6 Calcular la suma ponderada de facilidades de comunicación.
        df['comunicacion'] = df['telefono'] * 0.4 + df['celular'] * 0.2 + df['internet'] * 0.2 \
                             + df['tvcable'] * 0.2

        # *1.7 Calcular una media de comunicación por vivienda.
        df['codv'] = df['I01'].astype(str) + df['I02'].astype(str) + df['I03'].astype(str) \
                  + df['I04'].astype(str) + df['I05'].astype(str) +  df['I06'].astype(str) \
                  + df['I09'].astype(str)

        df['comunicacion'] = df['comunicacion'].astype(float)
        group = df.groupby('codv')['comunicacion'].mean()
        merge = pd.merge(df, group,  how='left', on='codv')
        merge.rename(columns={'comunicacion_y':'MEDIA_COMUNICACION'}, inplace=True) 
        df = merge

        # *2. CÁLCULO DEL INDICADOR INTEGRADO DE ENERGÍA.
        # *En esta base se calcula una parte, y en la base de datos de vivienda, se completa el cálculo.
        df['combu'] = None
        df.loc[df['H05'] == '7', 'combu'] = 1
        df.loc[(df['H05'] >= '4') & (df['H05'] <= '6'), 'combu'] = 0
        df.loc[(df['H05'] >= '1') & (df['H05'] <= '3'), 'combu'] = 1

        # *2.2 Calcular una media de Combustible por vivienda.
        df['combu'] = df['combu'].astype(float)
        group = df.groupby('codv')['combu'].mean()
        merge = pd.merge(df, group,  how='left', on='codv')
        merge.rename(columns={'combu_y':'MEDIA_COMBUSTIBLE'}, inplace=True) 
        df = merge

        # *3. CÁLCULO DEL HACINAMIENTO: DORMITORIOS.
        # *3.1 Considerar a los hogares unipersonales.
        df['hacina'] = 0.0
        df.loc[df['TP1'] == '1', 'hacina'] = 1

        # *3.2 Calcular el número de dormitorios por persona.
        df['TP1'] = df['TP1'].astype(float)
        df = trimSpaces(df, 'H01')
        df['H01'] = df['H01'].astype(float)
        df['dormitorio'] = df['H01'] / df['TP1']

        # *3.3 Normar el hacinamiento hasta un máximo de dos personas por dormitorio.
        df['HacinaDormitorio'] = df['dormitorio'] / 0.5

        # *3.4 Esta variable requiere de una recodificación, puesto que hay casos en los que el valor sobrepasa el máximo de 2
        # *3.4.1 Primero. Recalcular los hogares con valores mayores a 1, hasta un máximo de 2.
        # *3.4.2 Segundo. Copiar la variable inicial de hacinamiento, pero sólo los casos menores o iguales a 1.
        # *3.4.3 Tercero. Copiar los valores mayores a 1 que están recalculados.

        df['HACINA_RECOD'] = None
        maxHaci = df['HacinaDormitorio'].max()
        df.loc[df['HacinaDormitorio'] > 1, 'HACINA_RECOD'] = 1 + ((df['HacinaDormitorio'] - 1) / (32 - 1))
        df['HacinaDormitorio_2'] = None
        df.loc[df['HacinaDormitorio'] <= 1, 'HacinaDormitorio_2'] = df['HacinaDormitorio']
        df.loc[df['HACINA_RECOD'] > 1, 'HacinaDormitorio_2'] = df['HACINA_RECOD']

        # *4. OTRAS VARIABLES PARA EL CÁLCULO DE HACINAMIENTO.
        # *4.1 Calcular la existencia de cocina exclusiva para el hogar.
        df['cocina'] = None
        df.loc[df['H02'] == '1', 'cocina'] = 1
        df.loc[df['H02'] == '2', 'cocina'] = 0

        # *4.2 Calcular la existencia de baño exclusivo.
        df['bano'] = None
        df.loc[df['H03'] == '1', 'bano'] = 1
        df.loc[(df['H03'] >= '2') & (df['H03'] <= '3'), 'bano'] = 0

        # *4.3 Calcular la existencia de un cuarto extra por hogar.
        # *4.3.1 Primero. Sumar los dormitorios exclusivos de toda la vivienda.
        group = df.groupby('codv')['H01'].sum()
        merge = pd.merge(df, group,  how='left', on='codv')
        merge.rename(columns={'H01_y':'DORM_X_VIVIENDA'}, inplace=True) 
        df = merge

        # *4.3.2 Comprobar qué hogares tienen cuartos extras.
        # *OJO, PRIMERO PEGAR EN ESTA BASE LA VARIABLE DE VIVIENDA (V14).
        # *Para pegar variable V14.
        columns = ['V14', 'codv']
        dfVCuartos = pd.DataFrame(dfV, columns=columns)
        merge = pd.merge(df, dfVCuartos,  how='left', on='codv')
        df = merge

        df.loc[df['V14'] == ' ', 'V14'] = None
        df['CUARTOS_EXTRA'] = df['V14'].astype(float) - df['DORM_X_VIVIENDA'].astype(float)

        df['CUARTO_EXTRA1_0'] = None
        df.loc[df['CUARTOS_EXTRA'] >= 1, 'CUARTO_EXTRA1_0'] = 1
        df.loc[df['CUARTOS_EXTRA'] < 1, 'CUARTO_EXTRA1_0'] = 0

        # *4.4 Cálculo del Hacinamiento total. 'Hacinamiento por hogar (norma=1)'
        df['HACINAMIENTO'] = (df['HacinaDormitorio_2'].astype(float) + df['cocina'].astype(float)  
                             + df['bano'].astype(float) + df['CUARTO_EXTRA1_0'].astype(float)) / 4

        # *4.5 Calcular una media de Hacinamiento por vivienda.
        group = df.groupby('codv')['HACINAMIENTO'].mean()
        merge = pd.merge(df, group,  how='left', on='codv')
        merge.rename(columns={'HACINAMIENTO_y':'MEDIA_HACINAMIENTO'}, inplace=True) 
        df = merge

        # *5. Generar una base de datos auxiliar para pegarla luego a la base de vivienda con las 
        # variables de hacinamiento, comunicación y combustible.

        colsToCopy = ['codv', 'MEDIA_HACINAMIENTO', 'MEDIA_COMUNICACION', 'MEDIA_COMBUSTIBLE']
        dfAux = pd.DataFrame(df, columns=colsToCopy)
        rowsToCopy = dfAux.groupby('codv').first()

        merge = pd.merge(dfV, rowsToCopy,  how='left', on='codv')
        dfV = merge

        # PARA TRABAJAR EN LA BASE DE DATOS DE VIVIENDA DEL CENSO 2010, ECUADOR.
        # *1. CÁLCULO DE LAS CARACTERÍSTICAS FÍSICAS DE LA VIVIENDA.
        # *1.1 Calidad de la Vivienda
        # *1.1.1 Calidad del Techo.
        df = dfV
        df['TECHO'] = None
        df.loc[df['V01'] == '1', 'TECHO'] = 2
        df.loc[df['V01'] == '4', 'TECHO'] = 2
        df.loc[(df['V01'] >= '2') & (df['V01'] <= '3'), 'TECHO'] = 2
        df.loc[(df['V01'] >= '5') & (df['V01'] <= '6'), 'TECHO'] = 0

        # *1.1.2 Calidad de Paredes.
        df['PAREDES'] = None
        df.loc[df['V03'] == '5', 'PAREDES'] = 1
        df.loc[(df['V03'] >= '6') & (df['V03'] <= '7'), 'PAREDES'] = 0
        df.loc[(df['V03'] >= '3') & (df['V03'] <= '4'), 'PAREDES'] = 2
        df.loc[(df['V03'] >= '1') & (df['V03'] <= '2'), 'PAREDES'] = 3

        # *1.1.3 Calidad de Pisos.
        df['PISOS'] = None
        df.loc[df['V05'] == '4', 'PISOS'] = 1
        df.loc[df['V05'] == '1', 'PISOS'] = 2
        df.loc[df['V05'] == '3', 'PISOS'] = 2
        df.loc[df['V05'] == '2', 'PISOS'] = 0
        df.loc[(df['V05'] >= '5') & (df['V05'] <= '7'), 'PISOS'] = 0

        # *1.1.4 Es necesario reescalar cada variable de calidad con base en una escala de 0-1.
        df['CALITECHO'] = df['TECHO'] / 2
        df['CALIPAREDES'] = df['PAREDES'] / 3
        df['CALIPISOS'] = df['PISOS'] / 2

        # *1.1.5 Cálculo de indicador integrado de calidad de Vivienda.

        df['CALIVIVIENDA'] = (df['CALITECHO'].astype(float) * (1/3)) \
                            + (df['CALIPAREDES'].astype(float) * (1/3)) \
                            + (df['CALIPISOS'].astype(float) * (1/3))

        # *1.2. Confirmar que la variable de HACINAMIENTO se haya pegado de la base de datos de Hogar.
        # *1.3. Crear la variable de Características físicas de la vivienda.
        df['CFV'] = df['CALIVIVIENDA'] * 0.5 + df['MEDIA_HACINAMIENTO'] * 0.5

        # *2. DISPONIBILIDAD DE SERVICIOS BÁSICOS EN LA VIVIENDA.
        # *2.1 Agua y saneamiento para la vivienda. 'Disponibilidad de agua'.
        df['AGUA'] = None
        df.loc[df['V08'] == '1', 'AGUA'] = 3
        df.loc[df['V08'] == '2', 'AGUA'] = 2
        df.loc[df['V08'] == '3', 'AGUA'] = 1
        df.loc[df['V08'] == '4', 'AGUA'] = 0

        # *2.1.2 Agua reescalado.
        df['CALIAGUA'] = df['AGUA'] / 3

        #*2.1.3 Drenaje. 'Calidad de Drenaje'.
        df['DRENAJE'] = None
        df.loc[df['V09'] == '1', 'DRENAJE'] = 2
        df.loc[df['V09'] == '2', 'DRENAJE'] = 1
        df.loc[(df['V09'] >= '3') & (df['V09'] <= '6'), 'DRENAJE'] = 0

        # *2.1.4 Drenaje reescalado.
        df['CALIDRENAJE'] = df['DRENAJE'] / 2

        # *2.1.5 Desechos. 'Eliminación de desechos'.
        df['DESECHOS'] = None
        df.loc[df['V13'] == '1', 'DESECHOS'] = 1
        df.loc[(df['V13'] >= '2') & (df['V13'] <= '6'), 'DESECHOS'] = 0

        # *2.1.6 Indicador integrado de agua y saneamiento.
        df['AGUA_SANEAMIENTO'] = df['CALIAGUA'] * 0.4 + df['CALIDRENAJE'] * 0.4 + df['DESECHOS'] * 0.2


        # *2.2  Adecuación energética de la vivienda.
        # *2.2.2 Electricidad 0-1.Disponibilidad electricidad'.
        df['ELECTRICIDAD'] = None
        df.loc[df['V10'] == '5', 'ELECTRICIDAD'] = 0
        df.loc[(df['V10'] >= '1') & (df['V10'] <= '4'), 'ELECTRICIDAD'] = 1

        # *2.2.3 Adecuación Energética de la Vivienda: suma ponderada de combustible y electricidad.
        # 'Adecuación de energía (combustible+electricidad)'.
        df['ENERGIA'] = df['MEDIA_COMBUSTIBLE'] * 0.4 + df['ELECTRICIDAD'] * 0.6

        # *2.3 Adecuación en telecomunicaciones.
        # *2.4 Media de servicios.
        # *Primero es necesario pegar la variable de comunicación de la base de hogar.'Media de Servicios por Vivienda'.

        df['SERVICIOS'] = None
        df['SERVICIOS'] = df['AGUA_SANEAMIENTO'].astype(float) * 0.5 + df['ELECTRICIDAD'].astype(float) * 0.25 \
                         +  df['MEDIA_COMUNICACION'].astype(float) * 0.25

        # *3. Educación en la vivienda.
        # *4. Acceso a servicios de salud.
        # *5. Cáculo de CONDICIONES DE VIDA.
        if not 'VIVIENDA' in df.columns: 
            df.rename(columns={'CFV':'VIVIENDA'}, inplace=True) 
        if not 'EDUCACION' in df.columns:     
            df.rename(columns={'MEDIA_EDUCACION':'EDUCACION'}, inplace=True) 
        if not 'SEGURIDAD_SOCIAL' in df.columns:       
            df.rename(columns={'MEDIA_SEG_SOCIAL':'SEGURIDAD_SOCIAL'}, inplace=True) 

        # *5.1 Cálculo de la variable condiciones de vida. 
        df['CONDICIONES_VIDA'] = (df['VIVIENDA'].astype(float) + df['SERVICIOS'].astype(float) 
                                + df['EDUCACION'].astype(float) + df['SEGURIDAD_SOCIAL'].astype(float)) / 4

        # *5.2 Cálculo de variable Vivienda carente, hemos considerado un valor de .95, pero podría ser más alto.
        df['vivienda_carente'] = None
        df.loc[df['CONDICIONES_VIDA'] >= 0.95, 'vivienda_carente'] = 0
        df.loc[df['CONDICIONES_VIDA'] < 0.95, 'vivienda_carente'] = 1

        # *5.3 Carencias.
        df['Carencias'] = None
        df.loc[df['vivienda_carente'] == 1, 'Carencias'] = 0.95 - df['CONDICIONES_VIDA']

        # *5.4 Calcular variables comodín que ayuden a calcular las carecias de cada componente.
        df['Viv_car'] = None
        df.loc[df['VIVIENDA'] >= 0.95, 'Viv_car'] = 0
        df.loc[df['VIVIENDA'] < 0.95, 'Viv_car'] = 1

        df['Edu_car'] = None
        df.loc[df['EDUCACION'] >= 0.95, 'Edu_car'] = 0
        df.loc[df['EDUCACION'] < 0.95, 'Edu_car'] = 1

        df['SS_car'] = None
        df.loc[df['SEGURIDAD_SOCIAL'] >= 0.95, 'SS_car'] = 0
        df.loc[df['SEGURIDAD_SOCIAL'] < 0.95, 'SS_car'] = 1

        df['Serv_car'] = None
        df.loc[df['SERVICIOS'] >= 0.95, 'Serv_car'] = 0
        df.loc[df['SERVICIOS'] < 0.95, 'Serv_car'] = 1

        # *5.5. Cálculo de las carencias en cada componente.
        df['Carencia_vivienda'] = (0.95 - df['VIVIENDA']) * df['Viv_car']
        df['Carencia_educacion'] = (0.95 - df['EDUCACION']) * df['Edu_car']
        df['Carencia_segsocial'] = (0.95 - df['SEGURIDAD_SOCIAL']) * df['SS_car']
        df['Carencia_servicios'] = (0.95 - df['SERVICIOS']) * df['Serv_car']

        # *5.6 Cantidad de población carenciada.
        df['Carentes'] = df['TOTPER'] * df['vivienda_carente']


        # DIVIDIR EN 4 CUANTILES LAS CONDICIONES DE VIDA

        df['q1'] = None
        df['q2'] = None
        df['q3'] = None
        df['q4'] = None
        df['popQ1'] = None
        df['popQ2'] = None
        df['popQ3'] = None
        df['popQ4'] = None        

        quantiles = df['CONDICIONES_VIDA'].quantile([.25, .5, .75])
        q1 = quantiles[0.25]
        q2 = quantiles[0.50]
        q3 = quantiles[0.75]
        df.loc[df['CONDICIONES_VIDA'] <= q1, 'q1'] = 1.0
        df.loc[(df['CONDICIONES_VIDA'] > q1) & (df['CONDICIONES_VIDA'] <= q2), 'q2'] = 1.0
        df.loc[(df['CONDICIONES_VIDA'] > q2) & (df['CONDICIONES_VIDA'] <= q3), 'q3'] = 1.0
        df.loc[(df['CONDICIONES_VIDA'] > q3), 'q4'] = 1.0

        df['popQ1'] = df['TOTPER'] * df['q1']
        df['popQ2'] = df['TOTPER'] * df['q2']
        df['popQ3'] = df['TOTPER'] * df['q3']
        df['popQ4'] = df['TOTPER'] * df['q4']   

        # sacar numero de viviendas reales
        df['is_vivienda'] = None
        df.loc[(df['vivienda_carente'] == 0) | (df['vivienda_carente'] ==1 ), 'is_vivienda'] = 1.0
        df['is_vivienda'] = df['is_vivienda'].astype(float)             


        # *5.8 Base de datos por manzana.

        df['codman'] = df['I01'].astype(str) + df['I02'].astype(str) + df['I03'].astype(str) \
                  + df['I04'].astype(str) + df['I05'].astype(str) + df['I06'].astype(str)

        df['codsec'] = df['I01'].astype(str) + df['I02'].astype(str) + df['I03'].astype(str) \
                  + df['I04'].astype(str) + df['I05'].astype(str)


        importantColsForMan = ['codman','codv','vivienda_carente', 'Carencias', 'Carencia_vivienda', 
                         'Carencia_educacion', 'Carencia_segsocial', 'Carencia_servicios',
                        'Carentes', 'TOTPER', 'VIVIENDA', 'SERVICIOS', 'EDUCACION',
                        'SEGURIDAD_SOCIAL', 'CONDICIONES_VIDA', 'Viv_car', 'Edu_car',
                        'SS_car', 'Serv_car','id_man', 'id_viv', 'id_provin',
                        'id_can', 'id_parr','q1','q2','q3','q4','popQ1','popQ2','popQ3','popQ4','is_vivienda']

        importantColsForSec = ['codsec', 'codv', 'vivienda_carente', 'Carencias', 'Carencia_vivienda', 
                         'Carencia_educacion', 'Carencia_segsocial', 'Carencia_servicios',
                        'Carentes', 'TOTPER', 'VIVIENDA', 'SERVICIOS', 'EDUCACION',
                        'SEGURIDAD_SOCIAL', 'CONDICIONES_VIDA', 'Viv_car', 'Edu_car',
                        'SS_car', 'Serv_car', 'id_man', 'id_viv', 'id_provin',
                         'id_can', 'id_parr','q1','q2','q3','q4','popQ1','popQ2','popQ3','popQ4','is_vivienda']

        dfManzanas = pd.DataFrame(df, columns=importantColsForMan)
        # dfSectores = pd.DataFrame(df, columns=importantColsForSec)

        aggOptions = {'codv' : 'count',
                      'vivienda_carente':'sum', 
                      'Carencias':'sum',
                      'Carencia_vivienda' : 'sum',
                      'Carencia_educacion' : 'sum',
                      'Carencia_segsocial' : 'sum',
                      'Carencia_servicios' : 'sum',
                      'Carentes' : 'sum',
                      'TOTPER' : 'sum',
                      'VIVIENDA' : 'mean', 
                      'SERVICIOS' : 'mean',
                      'EDUCACION' : 'mean',
                      'SEGURIDAD_SOCIAL':'mean',
                      'CONDICIONES_VIDA':'mean',
                      'Viv_car' : 'sum',
                      'Edu_car' : 'sum',
                      'SS_car' : 'sum',
                      'Serv_car' : 'sum',
                      'codman' : 'first',
                      'q1':'sum',
                      'q2':'sum',
                      'q3':'sum',
                      'q4':'sum',
                      'popQ1': 'sum',
                      'popQ2': 'sum',
                      'popQ3': 'sum',
                      'popQ4': 'sum',
                      'is_vivienda' : 'sum'                                            
                     } 

        resManzanas = dfManzanas.groupby('codman').agg(aggOptions)    
        resManzanas.rename(columns={'is_vivienda':'viv_tot'}, inplace=True)
        resManzanas.rename(columns={'CONDICIONES_VIDA':'icv'}, inplace=True)        
        # resManzanas.loc[resManzanas['icv'] == ' ', 'icv'] = -9999   
        resManzanas['qt'] = resManzanas['q1'] + resManzanas['q2'] + resManzanas['q3'] + resManzanas['q4']
        resManzanas['popQt'] = resManzanas['popQ1'] + resManzanas['popQ2'] + resManzanas['popQ3'] + resManzanas['popQ4']        
        
        steps = steps+1
        feedback.setCurrentStep(steps)

        outputCsv = self.CURRENT_PATH+'/ICV.csv'
        feedback.pushConsoleInfo(str(('ICV en ' + outputCsv)))    
        resManzanas.to_csv(outputCsv, index=False)

        steps = steps+1
        feedback.setCurrentStep(steps)

        exitCsv = os.path.exists(outputCsv)
        if(exitCsv):
            print("El archivo CSV existe")
        else:
            print("No se encuentra CSV")

        CSV =  QgsVectorLayer(outputCsv, "csv", "ogr") 
        featuresCSV = CSV.getFeatures()
        # fields = layer.dataProvider().fields()
        field_names = [field.name() for field in CSV.fields()]       
        print(field_names)            

        steps = steps+1
        feedback.setCurrentStep(steps)

        steps = steps+1
        feedback.setCurrentStep(steps)
        resultIcv = joinByAttr2(params['BLOCKS'], fieldDpaMan,
                                outputCsv, 'codman',
                                [],
                                UNDISCARD_NONMATCHING,
                                '',
                                1,
                                context,
                                feedback)

        print("calculados")

        steps = steps+1
        feedback.setCurrentStep(steps)
        expressionNotNull = "icv IS NOT '' AND icv is NOT NULL"    
        icvNotNull =   filterByExpression(resultIcv['OUTPUT'], expressionNotNull, context, feedback) 

        # =====================
        # steps = steps+1
        # feedback.setCurrentStep(steps)
        # expressionNull = "icv IS '' OR icv is NULL"
        # icvNull =   filterByExpression(resultIcv['OUTPUT'], expressionNull, context, feedback, params['OUTPUT'])  
        # ----------------

        steps = steps+1
        feedback.setCurrentStep(steps)
        # formulaDummy = 'CASE WHEN icv IS NOT '' AND icv is NOT NULL THEN coalesce(icv * 1, NULL) ELSE NULL END'
        formulaDummy = 'icv * 1.0'
        result = calculateField(icvNotNull['OUTPUT'], 
                                 'icv_n',
                                 formulaDummy,
                                 context,
                                 feedback)     


        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'TOTPER * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'pob_tot',
                                 formulaDummy,
                                 context,
                                 feedback) 

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'Carentes * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'Pc',
                                 formulaDummy,
                                 context,
                                 feedback) 

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'pob_tot - Pc'
        result = calculateField(result['OUTPUT'], 
                                 'Po',
                                 formulaDummy,
                                 context,
                                 feedback)                                                                            

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'viv_tot * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'viv_tot',
                                 formulaDummy,
                                 context,
                                 feedback)                                        

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'vivienda_carente * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'Vc',
                                 formulaDummy,
                                 context,
                                 feedback)   


        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'viv_tot - Vc'
        result = calculateField(result['OUTPUT'], 
                                 'Vo',
                                 formulaDummy,
                                 context,
                                 feedback)   


        #----------------------cuartiles ICV de viviendas--------------------------------
        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'q1 * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'VQ1',
                                 formulaDummy,
                                 context,
                                 feedback) 

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'q2 * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'VQ2',
                                 formulaDummy,
                                 context,
                                 feedback)         

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'q3 * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'VQ3',
                                 formulaDummy,
                                 context,
                                 feedback)  

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'q4 * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'VQ4',
                                 formulaDummy,
                                 context,
                                 feedback)     

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'qt * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'VQt',
                                 formulaDummy,
                                 context,
                                 feedback)      

        #----------------------cuartiles ICV de pop--------------------------------
        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'popQ1 * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'PQ1',
                                 formulaDummy,
                                 context,
                                 feedback) 

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'popQ2 * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'PQ2',
                                 formulaDummy,
                                 context,
                                 feedback)         

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'popQ3 * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'PQ3',
                                 formulaDummy,
                                 context,
                                 feedback)  

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'popQ4 * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'PQ4',
                                 formulaDummy,
                                 context,
                                 feedback)     

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = 'popQt * 1.0'
        result = calculateField(result['OUTPUT'], 
                                 'PQt',
                                 formulaDummy,
                                 context,
                                 feedback)                                                                                                          


        steps = steps+1
        feedback.setCurrentStep(steps)        
        blocks = calculateArea(result['OUTPUT'], 'area_bloc', context,
                               feedback)        


        steps = steps+1
        feedback.setCurrentStep(steps)
        segments = intersection(blocks['OUTPUT'], gridNeto['OUTPUT'],
                                ['area_bloc','pob_tot','Pc','Po','viv_tot','Vc','Vo','icv_n', 
                                 'VQ1','VQ2','VQ3','VQ4', 'VQt',
                                 'PQ1','PQ2','PQ3','PQ4', 'PQt'
                                 ],
                                 'id_grid;area_grid',
                                context, feedback)

        steps = steps+1
        feedback.setCurrentStep(steps)
        segmentsArea = calculateArea(segments['OUTPUT'],
                                     'area_seg',
                                     context, feedback)

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * pob_tot' 
        resultForSegments = calculateField(segmentsArea['OUTPUT'], 'pop_tot_seg',
                                               formulaDummy,
                                               context,
                                               feedback)

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * Pc' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'Pc_seg',
                                               formulaDummy,
                                               context,
                                               feedback)   

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * Po' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'Po_seg',
                                               formulaDummy,
                                               context,
                                               feedback)   

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * viv_tot' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'viv_tot_seg',
                                               formulaDummy,
                                               context,
                                               feedback)

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * Vc' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'Vc_seg',
                                               formulaDummy,
                                               context,
                                               feedback)

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * Vo' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'Vo_seg',
                                               formulaDummy,
                                               context,
                                               feedback) 

        #----------------------cuartiles ICV de pop--------------------------------
        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * PQ1' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'pq1_seg',
                                               formulaDummy,
                                               context,
                                               feedback)

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * PQ2' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'pq2_seg',
                                               formulaDummy,
                                               context,
                                               feedback)

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * PQ3' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'pq3_seg',
                                               formulaDummy,
                                               context,
                                               feedback)        


        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * PQ4' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'pq4_seg',
                                               formulaDummy,
                                               context,
                                               feedback)

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * PQt' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'pqt_seg',
                                               formulaDummy,
                                               context,
                                               feedback)        

        #----------------------cuartiles ICV de viv--------------------------------    
        
        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * VQ1' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'vq1_seg',
                                               formulaDummy,
                                               context,
                                               feedback)   

        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * VQ2' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'vq2_seg',
                                               formulaDummy,
                                               context,
                                               feedback)                                                            


        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * VQ3' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'vq3_seg',
                                               formulaDummy,
                                               context,
                                               feedback)   


        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * VQ4' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'vq4_seg',
                                               formulaDummy,
                                               context,
                                               feedback)   


        steps = steps+1
        feedback.setCurrentStep(steps)
        formulaDummy = '(area_seg/area_bloc) * VQt' 
        resultForSegments = calculateField(resultForSegments['OUTPUT'], 'vqt_seg',
                                               formulaDummy,
                                               context,
                                               feedback)   


        # Haciendo el buffer inverso aseguramos que los segmentos
        # quden dentro de la malla
        steps = steps+1
        feedback.setCurrentStep(steps)
        resultForSegmentsFixed = makeSureInside(resultForSegments['OUTPUT'],
                                                    context,
                                                    feedback)        


        steps = steps+1
        feedback.setCurrentStep(steps)
        gridNeto = joinByLocation(gridNeto['OUTPUT'],
                             resultForSegmentsFixed['OUTPUT'],
                             ['pop_tot_seg','Pc_seg','Po_seg','viv_tot_seg','Vc_seg','Vo_seg',
                              'pq1_seg','pq2_seg','pq3_seg','pq4_seg','pqt_seg',
                              'vq1_seg','vq2_seg','vq3_seg','vq4_seg','vqt_seg'
                              ],                                   
                              [CONTIENE], [SUM],
                              UNDISCARD_NONMATCHING,
                              context,
                              feedback)         

        steps = steps+1
        feedback.setCurrentStep(steps)
        gridNeto = joinByLocation(gridNeto['OUTPUT'],
                             resultForSegmentsFixed['OUTPUT'],
                             ['icv_n'],                                   
                              [CONTIENE], [MEDIA],
                              UNDISCARD_NONMATCHING,
                              context,
                              feedback)  

        fieldsMapping = [
            {'expression': '"id_grid"', 'length': 10, 'name': 'id_grid', 'precision': 0, 'type': 4}, 
            {'expression': '"area_grid"', 'length': 16, 'name': 'area_grid', 'precision': 3, 'type': 6}, 
            {'expression': '"pop_tot_seg_sum"', 'length': 20, 'name': 'Pt', 'precision': 6, 'type': 6}, 
            {'expression': '"Pc_seg_sum"', 'length': 20, 'name': 'Pc', 'precision': 6, 'type': 6}, 
            {'expression': '"Po_seg_sum"', 'length': 20, 'name': 'Po', 'precision': 6, 'type': 6}, 
            {'expression': '"viv_tot_seg_sum"', 'length': 20, 'name': 'Vt', 'precision': 6, 'type': 6}, 
            {'expression': '"Vc_seg_sum"', 'length': 20, 'name': 'Vc', 'precision': 6, 'type': 6}, 
            {'expression': '"Vo_seg_sum"', 'length': 20, 'name': 'Vo', 'precision': 6, 'type': 6},

            {'expression': '"pq1_seg_sum"', 'length': 20, 'name': 'PQ1', 'precision': 6, 'type': 6}, 
            {'expression': '"pq2_seg_sum"', 'length': 20, 'name': 'PQ2', 'precision': 6, 'type': 6}, 
            {'expression': '"pq3_seg_sum"', 'length': 20, 'name': 'PQ3', 'precision': 6, 'type': 6}, 
            {'expression': '"pq4_seg_sum"', 'length': 20, 'name': 'PQ4', 'precision': 6, 'type': 6}, 
            {'expression': '"pqt_seg_sum"', 'length': 20, 'name': 'PQt', 'precision': 6, 'type': 6}, 

            {'expression': '"vq1_seg_sum"', 'length': 20, 'name': 'VQ1', 'precision': 6, 'type': 6}, 
            {'expression': '"vq2_seg_sum"', 'length': 20, 'name': 'VQ2', 'precision': 6, 'type': 6}, 
            {'expression': '"vq3_seg_sum"', 'length': 20, 'name': 'VQ3', 'precision': 6, 'type': 6}, 
            {'expression': '"vq4_seg_sum"', 'length': 20, 'name': 'VQ4', 'precision': 6, 'type': 6}, 
            {'expression': '"vqt_seg_sum"', 'length': 20, 'name': 'VQt', 'precision': 6, 'type': 6},             
            
            {'expression': '"icv_n_mean"', 'length': 20, 'name': NAMES_INDEX['ID07'][0], 'precision': 6, 'type': 6}
        ]      
        
        steps = steps+1
        feedback.setCurrentStep(steps)
        result = refactorFields(fieldsMapping, gridNeto['OUTPUT'], 
                                context,
                                feedback, params['OUTPUT'])                                                                

        return result
          
    def icon(self):
        return QIcon(os.path.join(pluginPath, 'sisurbano', 'icons', 'qualityLife.png'))

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'D07 Indice de calidad de vida'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'D Dinámicas socio-espaciales'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return ID07QualityLifeIndex()

    def shortHelpString(self):
        return  "<b>Descripción:</b><br/>"\
                "<span>Mide el nivel de carencia o bienestar de quienes habitan una vivienda en base a las siguientes variables: a) Características físicas de la vivienda, que integra tanto la calidad de la vivienda en pisos, paredes exteriores y techo, como la “cantidad de la vivienda” medida en hacinamiento de sus habitantes; b) Servicios básicos de la vivienda, que integra la información relacionada a servicios de agua y saneamiento, energía y comunicaciones; c) Educación, que caracteriza del nivel educativo de la población mayor a seis años; y d) Acceso a servicios de salud, que analiza el acceso de la población a un seguro de salud público o privado.</span>"\
                "<br/><br/><b>Justificación y metodología:</b><br/>"\
                "<span>Se utiliza la metodología desarrollada por Osorio y Orellana (2014) para la ciudad de Cuenca.</span>"\
                "<br/><br/><b>Formula:</b><br/>"\
                "<span>Para estandarizar los valores se utiliza la fórmula: Vi=Xi/Ui, Vi= valor estandarizado, Xi= puntaje de la variable, Ui= umbral previamente definido. Para las variables Dormitorios y Años de escolaridad se pueden obtener valores mayores a 2, reescalando los valores mayores a 1: Vi= 1 + ((Vi-1)/(maxV-1)). Finalmente se realiza una suma ponderada de los valores obtenidos para cada variable.</span><br/>"         

